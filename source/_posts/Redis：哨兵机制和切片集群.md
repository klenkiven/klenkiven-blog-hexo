---
title: Redis：哨兵机制和切片集群
sidebar:
  - toc
date: 2022-09-20 21:02:55
tags: [Redis]
categories: [Redis]
---

前面的文章提到了，Redis 的数据结构和 Redis 的持久化机制，保证了单机情况下 Redis 的可靠性和高性能。但是对于集群的场景下，只有持久化机制，也不能让 Redis 有更高的可靠性。例如，Redis 的主从集群，在主库挂掉以后，整个 Redis 集群便不能处理写操作了，这个时候就需要一个机制来保证主库挂掉也能正常运行 -- **哨兵机制**。对于需要大量存储缓存的时候，主从集群，需要主库的服务器有更高的性能或者存储，显然这样的需求并不可持续，如何让缓存能够分布存储，这就是 -- **切片集群**。

<!--more-->

## 哨兵机制：主库挂了该怎么办？

住过主库挂了，那么至少需要解决下面三个问题：

1. 主库真的挂了吗?
2. 该选择哪个从库作为主库?
3. 怎么把新主库的相关信息通知给从库和客户端呢?

这就要提到哨兵机制了。在Redis主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的这三个问题。

### 哨兵机制的基本流程

哨兵主要有三个任务：

- **监控**：监控主库的健康状况，判定主库是否掉线了
- **选主**：在主库客观下线以后，选出一个新的主库
- **通知**：在主库选定以后，需要将选举结果通知到各个从库

{% image https://klenkiven-blog-image.oss-cn-zhangjiakou.aliyuncs.com/REDIS-SENTINEL-01.png Redis 哨兵的工作流程 %}

其中，通知过程比较简单，通知给各个从库追随新的主库就好了，不涉及到决策逻辑。但是，**监控**和**选主**这两个任务，逻辑相对复杂。下面从**监控主库健康状况**和**选一个新的主库**两方面来讨论哨兵的基础机制。

### 主观下线和客观下线

**哨兵进程会使用PING命令检测它自己和主、从库的网络连接情况，用来判断实例的状态**。如果哨兵发现主库或从库对PING命令的响应超时了，那么，哨兵就会先把它标记为“**主观下线**”。

如果监测是从库，那么直接哨兵将其标记为“主观下线”即可。因为从库下线影响一般不太大，集群的对外服务不会间断。

但是，因为集群网络压力过大、网络阻塞问题造成哨兵**误判**，但是主库本身没有出现故障。可是，一旦启动了主从切换，并且通知从库和新主库进行数据同步，过程本身有很大的开销：**哨兵需要花时间选主**、**从库需要和新的主库进行同步**。但是，主库本身没有掉线，但是哨兵误判，造成了大量的资源浪费。

为了减少误判，我们需要一种机制去协商主库的在线状态。哨兵机制也是类似的，它**通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群**。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。同时，多个哨兵的网络同时不稳定的概率较小,由它们起做决策，误判率也能降低。

{% image https://klenkiven-blog-image.oss-cn-zhangjiakou.aliyuncs.com/REDIS-SENTINEL-02.png 哨兵集群判断客观下线 %}

### 如何选定一个新的主库？

一般来说，我把哨兵选择新主库的过程称为“**筛选+打分**”。简单来说，我们在多个从库中，先按照一定的**筛选条件**，把不符合条件的从库去掉。然后，我们再按照**一定的规则**，给剩下的从库逐个**打分**，将**得分最高的从库选为新主库**,如下图所示:

{% image https://klenkiven-blog-image.oss-cn-zhangjiakou.aliyuncs.com/REDIS-SENTINEL-03.png 哨兵选主 %}

接下来就是，根据一定的条件选择主库，在选择之前有一个前提条件：**网络状况良好**。

所以，在选主时，**除了要检查从库的当前在线状态,还要判断它之前的网络连接状态**。如果从库总是和主库断连，而且断连次数超出了一定的阈值，我们就有理由相信，这个从库的网络状况并不是太好，就可以把这个从库筛掉了。定量判定它的网络状况可以通过配置项 **`down-after-milliseconds`**。这个配置项的含义是：从库断开连接最大连接时间，如果超过 `down-after-milliseconds` 都没有连接上主库，那么就判定为从库连接断开。这个**断开连接次数超过 10 次**，这个从库的网络情况就很差，不适合作为新的主库。

在筛选完成以后，根据下面的顺序对存在的从库进行打分排序：

- 第一轮：**优先级 `slave-priority` 最高的从库得分高**
  一般来说，可以通过配置文件配置不同的从库，从库的配置文件中可以配置 `slave-priority` 预先确定一个顺序。例如，可以手动指定一个内存大的实例，使其优先级更高，减少在哨兵选主过程中的代价。

- 第二轮：**和旧主库同步程度最接近的从库得分最高**
  {% grid 同步程度如何定量计算？ %}
  在上一篇文章中，主从库数据同步的过程中，主库会使用 `master_repl_offset` 记录当先最新的写操作的位置，而从库会使用 `slave_repl_offset` 记录从库的复制进度。

  此时就可以通过判断从库的 `slave_repl_offset` 最接近主库的 `master_repl_offset`。得分最高的排名靠前。

  {% image https://klenkiven-blog-image.oss-cn-zhangjiakou.aliyuncs.com/REDIS-SENTINEL-04.png 从库同步程度 %}
  {% endgrid %}

- 第三轮：**ID号最小的从库得分高**
  每个实例都会有一个ID，这个ID就类似于这里的从库的编号。目前，Redis在选主库时，有一个默认的规定：**在优先级和复制进度都相同的情况下，ID号最小的从库得分最高，会被选为新主库**。

## 哨兵集群：哨兵挂了该怎么办？

## 切片集群：数据太大了该怎么办？
